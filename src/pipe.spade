use lib::regfile::regfile;
use lib::regfile::RegId;
use lib::icache::icache_read;
use lib::icache::ICache;

use lib::instructions::decode;
use lib::instructions::RegfileMode;
use lib::instructions::RFMuxing;
use lib::instructions::ExMode;

fn rs(ins: uint<32>) -> uint<5> {
    trunc(ins >> 6)
}

fn rt(ins: uint<32>) -> uint<5> {
    trunc(ins >> 11)
}

fn rd(ins: uint<32>) -> uint<5> {
    trunc(ins >> 16)
}

enum PipelineResult {
    Ok,
}

fn adder(mode: ExMode, x: uint<64>, y: uint<64>) -> uint<64> {
        let op_x = x;
        let (op_y, carry_in) = match mode {
            ExMode::Sub => (~y, 1),
            ExMode::SetLess => (~y, 1),
            ExMode::SetLessUnsigned => (~y, 1),
            _ => (y, 0),
        };

        let adder_out: uint<66> = (op_x + op_y + carry_in);
        let out64: uint<64> = trunc(adder_out);

        let carry_out: bool = (adder_out >> 64) == 1;
        let sign_out: bool = (out64 >> 63) == 1;

        match mode {
                ExMode::SetLess => if carry_out && !sign_out { 0 } else { 1 },
                ExMode::SetLessUnsigned => if carry_out { 0 } else { 1 },
                _ => trunc(adder_out),
        }
}

fn shifter(mode: ExMode, shift_mux: uint<64>, add_result: uint<64>) -> uint<64> {
    // Shifter:
        // The bottom 3, 5 or 6 bits of the adder are used as the shift amount.
        // Because this shifter is used to align the data for memory store operations,
        // it needs to shift based on the lower bits of the virtual address, which is
        // being calculated in the adder. So there is a tap to take the lower bits of
        // the add result before the add even completes.

        // This is a clever MIPS instruction encoding trick. A variable shift
        // instruction puts the shift amount in RS and requires that the SA field be 0.
        // A fixed shift instruction puts the shift amount in the SA field and requires
        // the RS field to be 0 (aka the zero register).
        // So the RF stage will always configure the adder to do RS + Imm, and
        // the Imm decoder will be configured to select the SA field.
        let shift5 = add_result & 0x1f;
        let shift6 = add_result & 0x3f;
        let byte_shift = (add_result & 0x7) << 3;

        let shift_result: uint<64> = match mode {
            ExMode::ShiftLeft         => trunc(shift_mux << shift5),
            ExMode::ShiftLeft64       => trunc(shift_mux << shift6),
            ExMode::ShiftRight        => trunc(shift_mux >> shift5),
            ExMode::ShiftRight64      => trunc(shift_mux >> shift6),
            ExMode::ShiftRightArith   =>
                int_to_uint(uint_to_int(shift_mux) >>> uint_to_int(shift5)),
            ExMode::ShiftRightArith64 =>
                int_to_uint(uint_to_int(shift_mux) >>> uint_to_int(shift6)),
            ExMode::Memory => {
                // The Shifter is also used to rotate the data for stores that aren't
                // 64-bit aligned.
                // The adder was calculating the virtual address, so we can take the
                // lower 3 bits of the result to determine the required byte shift.
                trunc(shift_mux << byte_shift)

                // TODO: post shift word order swap
            },
            _ => 0,
        };

        shift_result
}

pipeline(5) r4200_pipeline(clk: clock, icache: ICache) -> PipelineResult {
        'instruction_cache

        let pc = stage(execute).next_pc;
        let (ins, cache_tag, valid) = inst(1) icache_read(clk, icache, pc);
        // todo: micro-TLB read


    reg;
        'register_file
        let thispc = pc;

        let rs = RegId::Integer( rs(ins) );
        let rt = RegId::Integer( rt(ins) );
        let write = stage(writeback).regfile_write;

        let (rs_reg, rt_reg) = inst(0) regfile$(clk, rs, rt, write);
        let dest = RegId::Integer( rd(ins) );


    // TODO: bypass muxes
        let rs_val = rs_reg;
        let rt_val = rt_reg;

        let inst_info = decode(ins);
        let imm16: uint<16> = trunc(ins);
        let imm26: uint<26> = trunc(ins);
        let imm_shift: uint<5> = trunc(ins >> 6);

        let imm: uint<64> = match inst_info.rf_muxing {
            RFMuxing::RsImmSigned => int_to_uint(sext(uint_to_int(imm16))),
            RFMuxing::RsImmUnsigned => zext(imm16),
            RFMuxing::Shift => zext(imm_shift),
            RFMuxing::Shift64 => concat(1, imm_shift),
            RFMuxing::Memory => zext(imm16),
            RFMuxing::Jump26 => {
                let upper_bits = thispc & 0xffffffff_fc000000;
                upper_bits | zext(imm26)
            },
            _ => 0,
        };

        // The diagrams kind of imply that there are separate paths for logic operations,
        // but I think they actually use x/y again. But the diagrams are trying
        // to indicate that only certain values can be used, as logic always takes RS on the left and RT or Imm on the right.

        let (x_mux, y_mux, shift_mux) = match inst_info.rf_muxing {
            RFMuxing::RsRt => (rs_val, rt_val, 0),
            _ => (rs_val, imm, rt_val),
        };
    reg;
        'execute

    // 64-bit Carry-Propagate adder:
        let add_result = adder(inst_info.ex_mode, x_mux, y_mux);
        let data_virtual_address = add_result;

    // Shifter:
        let shift_result = shifter(inst_info.ex_mode, x_mux, add_result);


    // LogicOps:

        let logic_result = match inst_info.ex_mode {
            ExMode::And => trunc(x_mux & y_mux),
            ExMode::Or => trunc(x_mux | y_mux),
            ExMode::Xor => trunc(x_mux ^ y_mux),
            ExMode::Nor => trunc(~(x_mux | y_mux)),
            _ => 0,
        };
    // R Mux:
        // Logically it would make more sense to have a single 3-way Result mux later on.
        // But the shifter and logic ops are physically before the adder and multiplier
        // in the 64bit data-path, so by combining them early, there is one less wire to
        // run though the adder.

        let r_mux = match inst_info.ex_mode {
            ExMode::And => logic_result,
            ExMode::Or =>  logic_result,
            ExMode::Xor => logic_result,
            ExMode::Nor => logic_result,
            _ => shift_result,
        };

    // Result Mux:
        let result_mux = match inst_info.ex_mode {
            ExMode::Add => add_result,
            ExMode::Sub => add_result,
            ExMode::SetLess => add_result,
            ExMode::SetLessUnsigned => add_result,
            _ => r_mux,
        };

    // Sum Reg:
        // The sum reg is used to hold intermediate results of multi-cycle
        // multiplication and division operations.
        reg(clk) sum_reg = result_mux;

    // Packer:
        // todo: pack floating point results
        let packed = result_mux;

        let next_pc = trunc(thispc + 4);

    reg;
        'data_cache

    reg;
        'writeback
    // Load aligner:
        // The main shifter is used to align data for stores, but for timing
        // requirements, there is a separate shifter to align data from loads.


        let regfile_write = (dest, result_mux);

    reg;
        PipelineResult::Ok
}


pipeline(1) test_adder(clk: clock, mode: ExMode, x: uint<64>, y: uint<64>) -> uint<64> {
        let add_result = adder(mode, x, y);
    reg;
        add_result
}

pipeline(1) test_shifter(clk: clock, mode: ExMode, shift_mux: uint<64>, add_result: uint<64>) -> uint<64> {
        let shift_result = shifter(mode, shift_mux, add_result);
    reg;
        shift_result
}
