use lib::regfile::regfile;
use lib::regfile::RegId;
use lib::icache::icache_read;
use lib::icache::ICache;
use lib::icache::Request;
use lib::icache;

use lib::instructions::decode;
use lib::instructions::RegfileMode;
use lib::instructions::RFMuxing;
use lib::instructions::ExMode;

use std::ports::new_mut_wire;
use std::ports::read_mut_wire;


fn rs(ins: uint<32>) -> uint<5> {
    trunc(ins >> 6)
}

fn rt(ins: uint<32>) -> uint<5> {
    trunc(ins >> 11)
}

fn rd(ins: uint<32>) -> uint<5> {
    trunc(ins >> 16)
}

enum PipelineResult {
    Ok{next_pc: uint<64>},
    NotOk,
}

fn adder(mode: ExMode, x: int<64>, y: int<64>) -> int<64> {
        let op_x = int_to_uint(x);
        let y = int_to_uint(y);
        let (op_y, carry_in) = match mode {
            ExMode::Sub => (~y, 1),
            ExMode::SetLess => (~y, 1),
            ExMode::SetLessUnsigned => (~y, 1),
            _ => (y, 0),
        };

        let adder_out: uint<66> = (op_x + op_y + carry_in);
        let out64: int<64> = uint_to_int(trunc(adder_out));

        let carry_out: bool = (adder_out >> 64) == 1;
        let sign_out: bool = (out64 >> 63) == 1;

        match mode {
                ExMode::SetLess => if carry_out && !sign_out { 0 } else { 1 },
                ExMode::SetLessUnsigned => if carry_out { 0 } else { 1 },
                _ => out64,
        }
}

fn shifter(mode: ExMode, shift_mux: int<64>, add_result: int<64>) -> int<64>
{
    // Shifter:
        // The bottom 3, 5 or 6 bits of the adder are used as the shift amount.
        // Because this shifter is used to align the data for memory store operations,
        // it needs to shift based on the lower bits of the virtual address, which is
        // being calculated in the adder. So there is a tap to take the lower bits of
        // the add result before the add even completes.

        // This is a clever MIPS instruction encoding trick. A variable shift
        // instruction puts the shift amount in RS and requires that the SA field be 0.
        // A fixed shift instruction puts the shift amount in the SA field and requires
        // the RS field to be 0 (aka the zero register).
        // So the RF stage will always configure the adder to do RS + Imm, and
        // the Imm decoder will be configured to select the SA field.
        let shift5 = add_result & 0x1f;
        let shift6 = add_result & 0x3f;
        let byte_shift = (add_result & 0x7) << 3;

        let shift_result: int<64> = match mode {
            ExMode::ShiftLeft         => trunc(shift_mux << shift5),
            ExMode::ShiftLeft64       => trunc(shift_mux << shift6),
            ExMode::ShiftRight        => trunc(shift_mux >> shift5),
            ExMode::ShiftRight64      => trunc(shift_mux >> shift6),
            ExMode::ShiftRightArith   => shift_mux >>> shift5,
            ExMode::ShiftRightArith64 => shift_mux >>> shift6,
            ExMode::Memory => {
                // The Shifter is also used to rotate the data for stores that aren't
                // 64-bit aligned.
                // The adder was calculating the virtual address, so we can take the
                // lower 3 bits of the result to determine the required byte shift.
                trunc(shift_mux << byte_shift)

                // TODO: post shift word order swap
            },
            _ => 0,
        };

        shift_result
}

pipeline(5) r4200_pipeline(phase2: clock, phase1: clock, rst: bool, icache: ICache) -> PipelineResult {

    reg(phase1) pc  = stage(execute).nextpc;
        'instruction_cache // IC
        // Nothing happens in phase1 of the IC stage
        // It's waiting for the program counter to be calculated during EX phase1
        let (ins, cache_tag, valid) = inst(1) icache_read(phase1, icache, pc);
        // todo: micro-TLB read

    reg;
        'register_file

        let rs = RegId::Integer( rs(ins) );
        let rt = RegId::Integer( rt(ins) );
        let write = stage(writeback).regfile_write;

        let (rs_reg, rt_reg) = inst(0) regfile$(clk: phase2, rs, rt, write);
        let dest = RegId::Integer( rd(ins) );

    // TODO: bypass muxes
        let rs_val = rs_reg;
        let rt_val = rt_reg;

        let inst_info = decode(ins);
        let imm16: int<16> = uint_to_int(trunc(ins));
        let imm26: int<28> = uint_to_int(trunc(ins << 2));
        let imm_shift: int<5> = uint_to_int(trunc(ins >> 6));

        let imm: int<64> = match inst_info.rf_muxing {
            RFMuxing::RsImmSigned => sext(imm16),
            RFMuxing::RsImmUnsigned => concat(0, imm16),
            RFMuxing::Shift => concat(0, imm_shift),
            RFMuxing::Shift64 => concat(1, imm_shift),
            RFMuxing::Memory => sext(imm16),
            RFMuxing::Jump26 => {
                let upper_bits: int<36> = uint_to_int(trunc(pc >> 28));
                concat(upper_bits, imm26)
            },
            _ => 0,
        };

        // The diagrams kind of imply that there are separate paths for logic operations,
        // but I think they actually use x/y again. But the diagrams are trying
        // to indicate that only certain values can be used, as logic always takes RS on the left and RT or Imm on the right.

        let (x_mux, y_mux, shift_mux) = match inst_info.rf_muxing {
            RFMuxing::RsRt => (rs_val, rt_val, 0),
            _ => (rs_val, imm, rt_val),
        };
    reg;
        'execute // EX

        let thispc = stage(instruction_cache).pc;
        let reset_vector = 0xffffffff_bfc00000;
        let nextpc = if rst { reset_vector } else { trunc(thispc + 4)};

    // 64-bit Carry-Propagate adder:
        let add_result = adder(inst_info.ex_mode, x_mux, y_mux);
        let data_virtual_address = add_result;

    // Shifter:
        let shift_result = shifter(inst_info.ex_mode, x_mux, add_result);

    // LogicOps:
        let logic_result = match inst_info.ex_mode {
            ExMode::And => trunc(x_mux & y_mux),
            ExMode::Or => trunc(x_mux | y_mux),
            ExMode::Xor => trunc(x_mux ^ y_mux),
            ExMode::Nor => trunc(~(x_mux | y_mux)),
            _ => 0,
        };
    // R Mux:
        // Logically it would make more sense to have a single 3-way Result mux later on.
        // But the shifter and logic ops are physically before the adder and multiplier
        // in the 64bit data-path, so by combining them early, there is one less wire to
        // run though the adder.

        let r_mux = match inst_info.ex_mode {
            ExMode::And => logic_result,
            ExMode::Or =>  logic_result,
            ExMode::Xor => logic_result,
            ExMode::Nor => logic_result,
            _ => shift_result,
        };

    // Result Mux:
        let result_mux = match inst_info.ex_mode {
            ExMode::Add => add_result,
            ExMode::Sub => add_result,
            ExMode::SetLess => add_result,
            ExMode::SetLessUnsigned => add_result,
            _ => r_mux,
        };

    // Sum Reg:
        // The sum reg is used to hold intermediate results of multi-cycle
        // multiplication and division operations.
        reg(phase2) sum_reg = result_mux;

    // Packer:
        // todo: pack floating point results
        let packed = result_mux;

    reg;
        'data_cache

    reg;
        'writeback
    // Load aligner:
        // The main shifter is used to align data for stores, but for timing
        // requirements, there is a separate shifter to align data from loads.


        let regfile_write = (dest, result_mux);

    reg;
        PipelineResult::Ok(stage(execute).nextpc)
}

pipeline(1) test_adder(clk: clock, mode: ExMode, x: uint<64>, y: uint<64>) -> uint<64>
{
        let add_result = adder(mode, uint_to_int(x), uint_to_int(y));
    reg;
        int_to_uint(add_result)
}

pipeline(1) test_shifter(clk: clock, mode: ExMode, shift_mux: uint<64>, add_result: int<64>) -> uint<64>
{
        let shift_result = shifter(mode, uint_to_int(shift_mux), add_result);
    reg;
        int_to_uint(shift_result)
}

struct TestResult {
    next_pc: uint<64>,
    index: uint<13>,
}

pipeline(5) test_pipeline(
    phase1: clock,
    phase2: clock,
    rst: bool,
    ins: uint<32>,
    tag: uint<20>,
    valid: bool
) -> TestResult
{
    // Create a fake Instruction Cache
    let result = icache::Result$(
        data: ins,
        tag: tag,
        valid: valid,
    );
    let request = inst new_mut_wire();
    let icache = ICache$(request, result: &result);

    // instantiate the pipeline
    let status = inst(5) r4200_pipeline(phase2, phase1, rst, icache);


reg * 5;
    let next_pc = match status {
        PipelineResult::Ok(next_pc) => next_pc,
        PipelineResult::NotOk => 0,
    };

    let Request$( index: index ) = inst read_mut_wire(request);
    TestResult$(next_pc, index)
}