use lib::regfile::regfile;
use lib::regfile::RegId;
use lib::icache::icache_read;
use lib::icache::ICache;
use lib::icache::Request;
use lib::icache::Result;
use lib::icache;

use lib::instructions::decode;
use lib::instructions::RegfileMode;
use lib::instructions::RFMuxing;
use lib::instructions::ExMode;
use lib::instructions::Compare;
use lib::instructions::Trap;
use lib::instructions::MemMode;

use lib::dcache::dcache_access;
use lib::dcache::DCache;
use lib::dcache::DResult;
use lib::dcache::MemMask;
use lib::dcache::mem_mask;
use lib::dcache::null_mask;

use std::ports::new_mut_wire;
use std::ports::read_mut_wire;

fn rs(ins: uint<32>) -> uint<5> {
    trunc(ins >> 21)
}

fn rt(ins: uint<32>) -> uint<5> {
    trunc(ins >> 16)
}

fn rd(ins: uint<32>) -> uint<5> {
    trunc(ins >> 11)
}


enum PipelineResult {
    Ok{next_pc: uint<64>},
    NotOk,
}

fn adder(mode: ExMode, x: int<64>, y: int<64>) -> int<64> {
        let op_x = int_to_uint(x);
        let y = int_to_uint(y);
        let (op_y, carry_in) = match mode {
            ExMode::Sub32 => (~y, 1),
            ExMode::Sub64 => (~y, 1),
            ExMode::SetLess => (~y, 1),
            ExMode::SetLessUnsigned => (~y, 1),
            _ => (y, 0),
        };

        let adder_out: uint<66> = (op_x + op_y + carry_in);
        let out64: int<64> = uint_to_int(trunc(adder_out));
        let out32: int<32> = trunc(out64);

        let carry_out: bool = (adder_out >> 64) == 1;
        let sign_out: bool = (out64 >> 63) == 1;

        match mode {
                ExMode::SetLess => if carry_out && !sign_out { 0 } else { 1 },
                ExMode::SetLessUnsigned => if carry_out { 0 } else { 1 },
                ExMode::Add32 => sext(out32),
                ExMode::Sub32 => sext(out32),
                _ => out64,
        }
}

fn store_align(size: uint<4>, addr_bits: uint<3>, data: int<64>) -> (int<64>, MemMask)
{
    let mask = mem_mask(size, addr_bits);

    // let misalignment = addr_bits & 0x7;
    // let byte_shift = uint_to_int(concat(0, misalignment << 3));

    // The Shifter is also used to rotate the data for stores that aren't
    // 64-bit aligned.
    // The adder was calculating the virtual address, so we can take the
    // lower 3 bits of the result to determine the required byte shift.
    // let result = data << byte_shift;
    // let size_shift: uint<8> = zext(8 - size);

    let result = mask.align(int_to_uint(data));

    // TODO: post shift word order swap

    (uint_to_int(result), mask)
}

fn shifter(mode: ExMode, shift_mux: int<64>, add_result: int<64>) -> (int<64>, MemMask)
{
    // Shifter:
        // The bottom 3, 5 or 6 bits of the adder are used as the shift amount.
        // Because this shifter is used to align the data for memory store operations,
        // it needs to shift based on the lower bits of the virtual address, which is
        // being calculated in the adder. So there is a tap to take the lower bits of
        // the add result before the add even completes.

        // This is a clever MIPS instruction encoding trick. A variable shift
        // instruction puts the shift amount in RS and requires that the SA field be 0.
        // A fixed shift instruction puts the shift amount in the SA field and requires
        // the RS field to be 0 (aka the zero register).
        // So the RF stage will always configure the adder to do RS + Imm, and
        // the Imm decoder will be configured to select the SA field.
        let shift5 = add_result & 0x1f;
        let shift6 = add_result & 0x3f;
        let addr_bits = int_to_uint(trunc(add_result & 0x7));

        let (shift_result, mask) = match mode {
            ExMode::ShiftLeft         => (shift_mux << shift5, null_mask()),
            ExMode::ShiftLeft64       => (shift_mux << shift6, null_mask()),
            ExMode::ShiftRight        => (shift_mux >> shift5, null_mask()),
            ExMode::ShiftRight64      => (shift_mux >> shift6, null_mask()),
            ExMode::ShiftRightArith   => (shift_mux >>> shift5, null_mask()),
            ExMode::ShiftRightArith64 => (shift_mux >>> shift6, null_mask()),
            ExMode::InsertUpper       => (shift_mux << 16, null_mask()),
            ExMode::Memory(size) => store_align(size, addr_bits, shift_mux),
            _ => (0, null_mask()),
        };

        (shift_result, mask)
}

pipeline(5) r4200_pipeline(
    phase2: clock,
    phase1: clock,
    rst: bool,
    icache: ICache,
    dcache: DCache
) -> PipelineResult
{

    reg(phase1) pc  = stage(execute).nextpc;
        'instruction_cache // IC
        // Nothing happens in phase1 of the IC stage
        // It's waiting for the program counter to be calculated during EX phase1
        let (ins, cache_tag, valid) = inst(1) icache_read(phase1, icache, pc);
        // todo: micro-TLB read

    reg;
        'register_file

        let rs = RegId::Integer( rs(ins) );
        let rt = RegId::Integer( rt(ins) );
        let write = stage(writeback).regfile_write;

        let (rs_reg, rt_reg) = inst(0) regfile$(clk: phase2, rs, rt, write);
        let rd = RegId::Integer( rd(ins) );

    // TODO: bypass muxes
        let rs_val = rs_reg;
        let rt_val = rt_reg;

        let inst_info = decode(ins);
        let imm16: int<16> = uint_to_int(trunc(ins));
        let imm26: int<28> = uint_to_int(trunc(ins << 2));
        let imm_shift: int<5> = uint_to_int(trunc(ins >> 6));

        let (imm, dest) = match inst_info.rf_muxing {
            RFMuxing::RsImmSigned => (sext(imm16), rt),
            RFMuxing::RsImmUnsigned => (concat(0, imm16), rt),
            RFMuxing::ImmUpper => (sext(imm16), rt),
            RFMuxing::Shift => (concat(0, imm_shift), rd),
            RFMuxing::Shift64 => (concat(1, imm_shift), rd),
            RFMuxing::Memory => (sext(imm16), rt),
            RFMuxing::Jump26 => {
                let upper_bits: int<36> = uint_to_int(trunc(pc >> 28));
                (concat(upper_bits, imm26), RegId::Integer(0))
            },

            _ => (0, rd),
        };

        // The diagrams kind of imply that there are separate paths for logic operations,
        // but I think they actually use x/y again. But the diagrams are trying
        // to indicate that only certain values can be used, as logic always takes RS on the left and RT or Imm on the right.

        let (x_mux, y_mux, shift_mux) = match inst_info.rf_muxing {
            RFMuxing::RsRt => (rs_val, rt_val, 0),
            RFMuxing::ImmUpper => (rs_val, rt_val, imm),
            _ => (rs_val, imm, rt_val),
        };
    reg;
        'execute // EX

    // LogicOps:
        let is_zero = x_mux == 0;
        let is_neg = (x_mux >> 63) == 1;

        let logic_result = match inst_info.ex_mode {
            ExMode::And => trunc(x_mux & y_mux),
            ExMode::Or => trunc(x_mux | y_mux),
            ExMode::Xor => trunc(x_mux ^ y_mux),
            ExMode::Nor => trunc(~(x_mux | y_mux)),
            ExMode::Branch(cmp) => {
                let cmp_result = match cmp {
                    Compare::Equal => is_zero,
                    Compare::NotEqual => !is_zero,
                    Compare::GreaterThanZero => !is_neg && !is_zero,
                    Compare::GreaterEqualZero => !is_neg || is_zero,
                    Compare::LessThanZero => is_neg && !is_zero,
                    Compare::LessEqualZero => is_neg || is_zero,
                };
                if cmp_result { 1 } else { 0 }
            },
            _ => 0,
        };

    // Instruction Adder:
        let thispc = stage(instruction_cache).pc;
        let reset_vector = 0xffffffff_bfc00000;

        let nextpc = if rst {
            reset_vector
        } else {
            match inst_info.ex_mode {
                ExMode::Branch(_) => trunc(thispc +
                    if logic_result == 0 { 4 } else { int_to_uint(y_mux << 2) }
                ),
                ExMode::UnconditionalBranch => int_to_uint(x_mux),
                _ => trunc(thispc + 4),
            }
        };

    // 64-bit Carry-Propagate adder:
        let add_result = adder(inst_info.ex_mode, x_mux, y_mux);
        let data_virtual_address = int_to_uint(add_result);

    // Shifter:
        let (shift_result, mask) = shifter(inst_info.ex_mode, shift_mux, add_result);

    // R Mux:
        // Logically it would make more sense to have a single 3-way Result mux later on.
        // But the shifter and logic ops are physically before the adder and multiplier
        // in the 64bit data-path, so by combining them early, there is one less wire to
        // run though the adder.

        let r_mux = match inst_info.ex_mode {
            ExMode::And => logic_result,
            ExMode::Or =>  logic_result,
            ExMode::Xor => logic_result,
            ExMode::Nor => logic_result,
            _ => shift_result,
        };

    // Result Mux:
        let result_mux = match inst_info.ex_mode {
            ExMode::Add32 => add_result,
            ExMode::Add64 => add_result,
            ExMode::Sub32 => add_result,
            ExMode::Sub64 => add_result,
            ExMode::SetLess => add_result,
            ExMode::SetLessUnsigned => add_result,
            _ => r_mux,
        };

    // Sum Reg:
        // The sum reg is used to hold intermediate results of multi-cycle
        // multiplication and division operations.
        reg(phase2) sum_reg = result_mux;

    // Packer:
        // todo: pack floating point results
        let data = result_mux;

    reg;
        'data_cache
        // TODO: Get real tag from TLB
        let expected_tag: uint<20> = trunc(data_virtual_address >> 12);
        let index = match inst_info.mem_mode {
            MemMode::Nop => Option::None,
            MemMode::Discard => Option::None,
            _ => Option::Some(trunc(data_virtual_address >> 3)),
        };

        let dcache_access = inst(1) dcache_access(phase2, dcache, index, stage(+1).dcache_write);

    reg;
        'writeback
    // Complete any data cache writes
        let write_mask = match inst_info.mem_mode {
            MemMode::Store => Option::Some(mask),
            MemMode::ConditionalStore => Option::Some(mask),
            _ => Option::None,
        };

        let dcache_write = (data, write_mask);

    // Load aligner:
        // The main shifter is used to align data for stores, but for timing
        // requirements, there is a separate shifter to align data from loads.
        let aligned_load = uint_to_int(mask.extract(dcache_access.data));

        let regfile_write = match inst_info.mem_mode {
            MemMode::Nop => (dest, result_mux),
            MemMode::Discard => (RegId::Integer(0), 0),
            MemMode::Load => (dest, aligned_load),
            MemMode::Store => (RegId::Integer(0), 0),
            MemMode::Cache => (RegId::Integer(0), 0),
            LinkedLoad => (dest, aligned_load),
            ConditionalStore => (dest, 1), // TODO: check link register
        };

    reg;
        PipelineResult::Ok(stage(instruction_cache).pc)
}

pipeline(1) test_adder(clk: clock, mode: ExMode, x: uint<64>, y: uint<64>) -> uint<64>
{
        let add_result = adder(mode, uint_to_int(x), uint_to_int(y));
    reg;
        int_to_uint(add_result)
}

pipeline(1) test_shifter(clk: clock, mode: ExMode, shift_mux: uint<64>, add_result: int<64>) -> uint<64>
{
        let (shift_result, mask) = shifter(mode, uint_to_int(shift_mux), add_result);
    reg;
        int_to_uint(shift_result)
}

struct TestResult {
    next_pc: uint<64>,
    index: uint<13>,
    d_index: Option<uint<12>>,
    write: uint<64>,
    write_mask: MemMask,
    write_en: bool,
}

pipeline(5) test_pipeline(
    phase1: clock,
    phase2: clock,
    rst: bool,
    ins: uint<32>,
    tag: uint<20>,
    valid: bool,
    data: uint<64>,
    d_tag: uint<20>,
    d_valid: bool,
) -> TestResult
{
    // Create a fake Instruction Cache
    let result = icache::Result$(
        data: ins,
        tag: tag,
        valid: valid,
    );
    let request = inst new_mut_wire();
    let icache = ICache$(request, result: &result);

    // And a fake Data Cache
    let d_result = DResult$(data: data, tag: d_tag, valid: d_valid);
    let d_index = inst new_mut_wire();
    let d_write = inst new_mut_wire();
    let d_write_mask = inst new_mut_wire();

    let dcache = DCache$(
        index: d_index,
        result: &d_result,
        write: d_write,
        write_mask: d_write_mask,
    );

    // instantiate the pipeline
    let status = inst(5) r4200_pipeline(phase2, phase1, rst, icache, dcache);


reg * 5;
    let next_pc = match status {
        PipelineResult::Ok(next_pc) => next_pc,
        PipelineResult::NotOk => 0,
    };

    let Request$( index: index ) = inst read_mut_wire(request);
    let write = inst read_mut_wire(d_write);
    let (write_mask, write_en) = match inst read_mut_wire(d_write_mask) {
        Option::Some(mask) => (mask, true),
        Option::None => (null_mask(), false),
    };
    let d_index = inst read_mut_wire(d_index);

    TestResult$(next_pc, index, write, write_mask, write_en, d_index)
}
