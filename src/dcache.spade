

struct MemMask {
    size: uint<3>, // 0 indexed
    align: uint<3>, // alignment within octbyte
}

impl MemMask {
    fn mask(self) -> uint<8> {
        (0b11111111 >> (7 - zext(self.size))) << zext(self.align)
    }

    fn byte_mask(self) -> uint<64> {
        let inv_size: uint<64> = 7 - zext(self.size);
        let right_shift = inv_size << 3;
        let left_shift = trunc(inv_size - zext(self.align)) << 3;

        (0xffffffffffffffff >> right_shift) << left_shift
    }

    fn clear(self, dest: uint<64>) -> uint<64> {
        let mask = self.byte_mask();
        dest & ~mask
    }

    fn align(self, data: uint<64>) -> uint<64> {
        let shift = ((7 - zext(self.size)) - zext(self.align)) << 3;
        data << shift
    }

    fn insert(self, dest: uint<64>, data: uint<64>) -> uint<64> {
        let mask = self.byte_mask();
        (dest & ~mask) | (self.align(data) & mask)
    }

    fn extract(self, data: uint<64>) -> uint<64> {
        let inv_size: uint<64> = 7 - zext(self.size);
        let left_shift = inv_size << 3;
        let right_shift = trunc(inv_size - zext(self.align)) << 3;
        (data << left_shift) >>> right_shift
    }

    fn size(self) -> uint<4> {
        self.size + 1
    }
}


fn mem_mask<N, M>(size: uint<N>, addr: uint<M>) -> MemMask {
    MemMask$ (size: trunc(size - 1), align: trunc(addr))
}

fn null_mask() -> MemMask {
    MemMask$ (size: 0, align: 0)
}

struct DResult {
    data: uint<64>,
    tag: uint<20>,
    valid: bool,
    busy: bool,
}

struct port DCache {
    index: &mut Option<uint<12>>,
    result: &DResult,
    write: &mut uint<64>,
    write_mask: &mut Option<MemMask>,
}

pipeline(1) dcache_access(clk: clock, dcache: DCache, index: uint<12>, read_en: bool, write: (bool, uint<64>, MemMask)) -> DResult
{
        let (write_en, data, write_mask) = write;

        set dcache.index = if read_en || write_en Option::Some(index) else Option::None;
        set dcache.write = data;
        set dcache.write_mask = if write_en Option::Some(write_mask) else Option::None;
    reg;
        *dcache.result
}
